 /******************************************************************************************
 * BST节点初除算法：初除位置x所指癿节点（全局静态模板函数，适用亍AVL、Splay、RedBlack等各种BST）
 * 目标x在此前经查找定位，并确认非NULL，故必删除成功；与searchIn不同，调用之前不必将hot置空
 * 返回值指向实际被删除节点的接替者，hot指向实际被删除节点的父亲————二者均有可能是NULL
 ******************************************************************************************/


BinNodePosi(T) removeAt(BinNodePosi(T) x, BinNodePosi(T) _hot) {
    BinNodePosi(T) w = x;//实际被摘除的节点，初值同x
    BinNodePosi(T) succ = NULL;//实际被摘除者的直接后继，接替者
    //分两种情况处理
    //1.只有单一子节点
    if (!HasLChild(*x)) {//若左树为空，则
        succ = x = x->rc;//直接将*x替换为其右子树
    }
    else if (!HasRChild(*x)){//若右树为空，则
        succ = x = x->lc;//直接将*x替换为其左子树
    }
    //2.两个节点均存在
    else{
        w = w->succ();//在(右子树中)找到x的直接后继w
        swap(w->data, x->data);//交换两个x和x的后继的值
        BinNodePosi(T) u = w->parent;//记住后继的父亲，给删除该后续提供便利
        //判断后继和其父亲是否相等？后继只有右节点，且一定不大于后继的父亲（后继只能是父亲的左节点，由BST的顺序性可验证“不大于”）
        //若相等，直接将右节点接到父亲的右节点
        //反之，后继的右节点肯定小于父节点，直接接到父亲的左节点
        ((u == x) ? u->rc : u->lc) = succ = w->rc;
    }
    hot = w->parent;//记录实际被删除节点的父亲
    if(succ) succ->parent = hot;//并将删除节点的接替者与hot相联
    release(w->data); release(w); return succ;//释放摘除者，返回接替者
}